---
title: Python Cryptography
permalink: /assignments/pa2_5_crypto
key: assignments-pa2_5_crypto
layout: article
nav_key: assignments
sidebar:
  nav: assignments
license: false
aside:
  toc: true
show_edit_on_github: false
show_date: false
---

The Python [`cryptography`](https://pypi.org/project/cryptography/) module is pretty straightforward to use. We will highlight here a few methods that are necessary for this assignment to save your time.

> You can install the `cryptography` module using `pip`: `python3.10 -m pip install cryptography`. Make sure that it is installed to your `Python3.10` and not your previous versions of Python, that is to call the `pip` with the `python3.10` version (make sure its in `$PATH`, no other alias, etc). If you don't know how to manage your modules for different versions of Python, please Google harder and try to understand how things are _installed_ in your computer from your knowledge about the OS and the File System. We are _way_ past this right now.

You can skim the sections below or jump straight ahead to read their official documentation about RSA (Asymmetric encryption) [here](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/?highlight=rsa) and Fernet (Symmetric encryption) [here](https://cryptography.io/en/latest/fernet/).

## Key Generation

In `source/auth/generate_keys.py`, we have provided you with instructions on how to generate 1024-bit RSA key pair. You can run the script as such:

```
cd source/auth
python3 generate_keys.py server
```

Two files will be produced in `source/auth`:

1. `server_private_key.pem`: private key for server program (note that private key file also contain public key information as well)
2. `server_csr.pem`: certificate signing request file, to be sent to our CA bot for signing purposes. The CA will return a `.crt` file containing the server's public key.

Do <span style="color:#f77729;"><b>not</b></span> change the <span style="color:#f77729;"><b>names</b></span> of the files generated by `generate_keys.py`. Do <span style="color:#f77729;"><b>not</b></span> change the <span style="color:#f77729;"><b>location</b></span> of the files either. The two above must be placed in `source/auth`.
{:.error}

## Reading Certificate

You can extract a public key from a `.crt` file. For instance, we give you `cacsertificate.crt` file containing our CA's public key. You can use the CA public key later on to <span style="color:#f77729;"><b>verify</b></span> the authenticity of the certificate sent by the server.

First, you can open the `.crt` file as per normal as `bytes` data type,

```python
from cryptography import x509
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend

f = open("auth/cacsertificate.crt", "rb")
ca_cert_raw = f.read()
```

Then use the `x509` method to load it:

```python
ca_cert = x509.load_pem_x509_certificate(
    data=ca_cert_raw, backend=default_backend()
)
```

Afterwards, you can get a public key from the certificate:

```python
ca_public_key = ca_cert.public_key()
```

## Verify signature

You can use a <span style="color:#f77729;"><b>public key</b></span> to verify any signature data. For instance, suppose you have `server_cert_raw` byte data, containing the information about the <span style="color:#f77729;"><b>signed</b></span> server certificate by the CA. You can <span style="color:#f77729;"><b>verify</b></span> that this `server_cert_raw` is <span style="color:#f77729;"><b>indeed</b></span> issued by the CA using the `verify` method:

```python
server_cert = x509.load_pem_x509_certificate(
    data=server_cert_raw, backend=default_backend()
)

ca_public_key.verify(
    signature=server_cert.signature, # signature bytes to  verify
    data=server_cert.tbs_certificate_bytes, # certificate data bytes that was signed by CA
    padding=padding.PKCS1v15(), # padding used by CA bot to sign the the server's csr
    algorithm=server_cert.signature_hash_algorithm,
)
```

An `InvalidSignature` exception will be <span style="color:#f77729;"><b>raised</b></span> if the signature fails to verify. Otherwise, the instructions will continue.
{:.warning}

Then you can also extract server's public key from `server_cert` after it passes the verification:

```python
server_public_key = server_cert.public_key()
```

## Check Certificate Validity

It is also <span style="color:#f77729;"><b>important</b></span> to check the validity of a certificate before proceeding with the FTP. You can do this easily by doing:

```python
import datetime

assert server_cert.not_valid_before <= datetime.utcnow() <= server_cert.not_valid_after
```

## Reading a .pem file

You can <span style="color:#f77729;"><b>extract</b></span> both the private key and public key from the `.pem` file generated by `generate_keys.py`. There's no password used by default.

```python
try:
    with open("auth/server_private_key.pem", mode="r", encoding="utf8") as key_file:
        private_key = serialization.load_pem_private_key(
            bytes(key_file.read(), encoding="utf8"), password=None
        )
    public_key = private_key.public_key()
except Exception as e:
    print(e)

# Use private_key or public_key for encryption or decryption from now onwards
```

## Sign Message and Verify

We <span style="color:#f77729;"><b>sign</b></span> a message by encrypting it with our `private_key`. For instance,

```python
message = bytes("hello world", encoding="utf-8")
signed_message = private_key.sign(
        message, # message in bytes format
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH,
        ),
        hashes.SHA256(), # hashing algorithm used to hash the data before encryption
    )
```

We can then verify the `message` using the `verify` method that we have seen above with the <span style="color:#f7007f;"><b>corresponding</b></span> `public_key`, otherwise will raise `InvalidSignature` Exception.

```python
public_key.verify(
    signed_message,
    message,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH,
    ),
    hashes.SHA256(),
)
# will continue here if the verify above passes
```

Note that in the above example, `SHA256` is used to <span style="color:#f77729;"><b>hash</b></span> the `message` first before encrypting it with `private_key`.

The padding used for the example above is [`PSS`](https://en.wikipedia.org/wiki/Probabilistic_signature_scheme). It is a <span style="color:#f77729;"><b>new signature padding scheme</b></span> standard that should be used to pad <span style="color:#f77729;"><b>signatures</b></span> securely. You may read more about it [here](https://www.cryptosys.net/pki/manpki/pki_rsaschemes.html) but it is out of our syllabus scope.

Also note that in the above `ca_public_key.verify` example, we used the old `padding.PKCS1v15()` because that's just how our CA bot signed the `.csr`, however when our server signs the client's message, it can use the more advanced `PSS` padding. Conversely, the client <span style="color:#f77729;"><b>must</b></span> also use `PSS` padding if the server used it to pad the digital signature.

## Standard Encryption

You can <span style="color:#f77729;"><b>encrypt</b></span> a message with a `public_key`.

> In the section above, you encrypt a message with a `private_key`, and we call this <span style="color:#f7007f;"><b>signing</b></span> instead.

```python
message = bytes("hello world", encoding="utf-8")
encrypted_message = public_key.encrypt(
        message,
        padding.OAEP(
            mgf=padding.MGF1(hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None,
        ),
    )
```

## Padding and Message Size

Note that in the example above, [`OAEP`](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding) padding scheme is used. This is an RSA <span style="color:#f77729;"><b>encryption padding scheme</b></span> (as opposed to `PSS`, which is a signature padding scheme).

> Note that there are two RSA <span style="color:#f77729;"><b>signature</b></span> schemes specified in [PKCS1](https://www.cryptosys.net/pki/manpki/pki_References.html#PKCS1): RSASSA-PKCS1-v1_5 and RSASSA-PSS, and there are two RSA <span style="color:#f77729;"><b>encryption</b></span> schemes: RSAES-PKCS-v1_5 and RSAES-OAEP. The details are out of our syllabus.

The <span style="color:#f77729;"><b>minimum</b></span> length of `OAEP` padding is 66 bytes. A `1024` bit RSA keys can at most encrypt 128 bytes of message data chunk at a time. With 66 bytes of padding at minimum this leaves us with 62 bytes of message to encrypt at a time.
{:.error}

If you were to encrypt with `PKCS1v15` instead (min 11 bytes of padding):

```python
encrypted_message = public_key.encrypt(message, padding.PKCS1v15())
```

Then the maximum length of the message to encrypt at a time with 1024 bit RSA key is 117 bytes.

It is up to you to <span style="color:#f77729;"><b>choose</b></span> which padding implementation to use to encrypt the chunk of messages (file data) sent by client to the server. Just ensure that you set the chunk size accordingly.

## Standard Decryption

You can <span style="color:#f77729;"><b>decrypt</b></span> a message with a `private_key`.

> Again, you can also decrypt a signed message with a `public_key`, but the keyword used here is `verify` and not standard "decryption".

```python
decrypted_message = private_key.decrypt(
      encrypted_message, # in bytes
      padding.OAEP(      # padding should match whatever used during encryption
          mgf=padding.MGF1(hashes.SHA256()),
          algorithm=hashes.SHA256(),
          label=None,
      ),
  )
```

You can also <span style="color:#f77729;"><b>decrypt</b></span> a message with a `public_key`. In order to _decrypt_ with a public key, this message has to be _encrypted_ with a private key, and we call this a <span style="color:#f77729;"><b>signature</b></span> (instead of regular encrypted message). You have seen this in the [previous](https://natalieagus.github.io/assignments/pa2_5_crypto#sign-message-and-verify) section above.

## Generating a Symmetric Key

You can generate a symmetric key as <span style="color:#f77729;"><b>session key</b></span> for a better file encryption performance. You can use the [`Fernet`](https://cryptography.io/en/latest/fernet/) method to generate a <span style="color:#f77729;"><b>secure</b></span> symmetric key, instead of the usual AES/3DES. It is really simple to use:

```python
from cryptography.fernet import Fernet
session_key_bytes = Fernet.generate_key() # generates 128-bit symmetric key as bytes
session_key = Fernet(session_key_bytes) # instantiate a Fernet instance with key
```

## Using a Symmetric Key

Unlike RSA encryption, you can `encrypt` any byte datatype without separating them into chunks:

```python
long_message = b""
with open("source/files/image.ppm", "rb") as f:
  long_message = f.read()
encrypted_long_message = session_key.encrypt(long_message)
decrypted_long_message = session_key.decrypt(encrypted_long_message)
assert decrypted_long_message == long_message
```

You may _experiment_ with <span style="color:#f77729;"><b>other</b></span> [symmetric key algorithms](https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/) if you wish, but for this assignment, we <span style="color:#f7007f;"><b>expect you to use Fernet</b></span>.

## More details

More documentation details can always be found at their [official documentation page](https://cryptography.io/en/latest/). Utilise their search bar.
